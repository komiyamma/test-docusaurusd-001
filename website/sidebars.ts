import type { SidebarsConfig } from '@docusaurus/plugin-content-docs';

// This runs in Node.js - Don't use client-side code here (browser APIs, JSX...)

// Function to generate file IDs with configurable folder and prefix
function generateStudyIds(folder: string, prefix: string, start: number, end: number): string[] {
  const ids: string[] = [];
  for (let i = start; i <= end; i++) {
    const idStr = i.toString().padStart(3, '0');
    ids.push(`${folder}/${prefix}_study_${idStr}`);
  }
  return ids;
}

const reactModules = [
  { title: "Module 1: 準備とTypeScriptの「考え方」", start: 1, end: 10 },
  { title: "Module 2: JSXと「型」のキホン", start: 11, end: 20 },
  { title: "Module 3: Props（型付きデータの受け渡し）", start: 21, end: 30 },
  { title: "Module 4: useStateとイベントの「型」", start: 31, end: 40 },
  { title: "Module 5: UIの動的構築（型と一緒に）", start: 41, end: 50 },
  { title: "Module 6: スタイリング", start: 51, end: 55 },
  { title: "Module 7: useEffect（「表示」以外のウラ仕事）", start: 56, end: 65 },
  { title: "Module 8: useReducer（型でガチガチに管理）", start: 66, end: 70 },
  { title: "Module 9: useContext（型付きの「みんなのデータ」）", start: 71, end: 80 },
  { title: "Module 10: 動きをサクサクにする", start: 81, end: 90 },
  { title: "Module 11: useRef 集中講座", start: 91, end: 100 },
  { title: "Module 12: 知ってると便利なフックたち", start: 101, end: 110 },
  { title: "Module 13: v19データ取得 use & Suspense", start: 111, end: 120 },
  { title: "Module 14: v19フォーム革命 Actions", start: 121, end: 130 },
  { title: "Module 15: カスタムフック（オリジナルのフック）", start: 131, end: 140 },
  { title: "Module 16: ルーティングとプロジェクト構成", start: 141, end: 150 },
  { title: "Module 17: テストと公開", start: 151, end: 160 },
  { title: "Module 18: 非同期データの最強管理術 (TanStack Query)", start: 161, end: 170 },
  { title: "Module 19: グローバルステート管理の決定版 (Zustand)", start: 171, end: 180 },
  { title: "Module 20: フォームバリデーションの鉄板 (RHF & Zod)", start: 181, end: 190 },
  { title: "Module 21: ユーザー認証と「自分だけのアプリ」", start: 191, end: 200 },
  { title: "Module 22: アニメーションで「プロ感」を出す", start: 201, end: 210 },
  { title: "Module 23: UIライブラリで「車輪の再発明」を防ぐ", start: 211, end: 220 },
  { title: "Module 24: AI統合とストリーミング (Vercel AI SDK)", start: 221, end: 230 },
  { title: "Module 25: 信頼性を高めるE2Eテスト (Playwright)", start: 231, end: 240 },
  { title: "Module 26: アトミックな状態管理 (Jotai)", start: 241, end: 250 },
  { title: "Module 27: 次世代バリデーション (Valibot)", start: 251, end: 260 },
  { title: "Module 28: 次世代ビルドツール (Biome)", start: 261, end: 270 },
  { title: "Module 29: React Email メール実装革命", start: 271, end: 280 },
  { title: "Module 30: フルスタック・エッジ開発 (Hono & Cloudflare)", start: 281, end: 290 },
];

const nextModules = [
  { title: "Module 1: Next.jsってなに？全体像をつかむ", start: 1, end: 10 },
  { title: "Module 2: プロジェクト作成と初期設定", start: 11, end: 22 },
  { title: "Module 3: App Router 基本", start: 23, end: 36 },
  { title: "Module 4: コンポーネント設計", start: 37, end: 48 },
  { title: "Module 5: スタイリング", start: 49, end: 60 },
  { title: "Module 6: ルーティング応用", start: 61, end: 74 },
  { title: "Module 7: データ取得（基本）とキャッシュ感覚", start: 75, end: 90 },
  { title: "Module 8: Suspense / Streaming / エラー設計", start: 91, end: 104 },
  { title: "Module 9: Route Handlers（API）入門", start: 105, end: 118 },
  { title: "Module 10: MiddlewareとEdgeの考え方", start: 119, end: 132 },
  { title: "Module 11: Server Actions & フォーム革命", start: 133, end: 150 },
  { title: "Module 12: セキュリティ基本（XSS/CSRF/依存更新）", start: 151, end: 160 },
  { title: "Module 13: DBとCRUD（Prisma想定）", start: 161, end: 174 },
  { title: "Module 14: 認証（Auth.js/NextAuth系の考え方）", start: 175, end: 188 },
  { title: "Module 15: 画像・フォント・SEO", start: 189, end: 202 },
  { title: "Module 16: テスト（Vitest / RTL / E2E）", start: 203, end: 218 },
  { title: "Module 17: デプロイ & 運用（Vercel中心）", start: 219, end: 232 },
  { title: "Module 18: 卒業制作（企画→実装→公開）", start: 233, end: 244 },
  { title: "Module 19: 運用保守・エコシステム", start: 245, end: 254 },
  { title: "Module 20: App Router時代の状態管理（Server連携特化）", start: 255, end: 264 },
  { title: "Module 21: 次世代スタイリング（Panda CSS）", start: 265, end: 274 },
  { title: "Module 22: 次世代バリデーション（Valibot）", start: 275, end: 284 },
];

/**
 * Creating a sidebar enables you to:
 - create an ordered group of docs
 - render a sidebar for each doc of that group
 - provide next/previous navigation

 The sidebars can be generated from the filesystem, or explicitly defined here.

 Create as many sidebars as you want.
 */
const sidebars: SidebarsConfig = {
  // By default, Docusaurus generates a sidebar from the docs folder structure
  tutorialSidebar: [
    'intro',
    {
      type: 'category',
      label: 'Tutorial',
      items: [
        {
          type: 'autogenerated',
          dirName: 'tutorial-basics',
        },
        {
          type: 'autogenerated',
          dirName: 'tutorial-extras',
        },
      ],
    },
  ],
  reactStudySidebar: [
    'react-study/react_index',
    ...reactModules.map(mod => ({
      type: 'category' as const,
      label: mod.title,
      items: generateStudyIds('react-study', 'react', mod.start, mod.end),
    })),
  ],
  nextStudySidebar: [
    'next-study/next_index',
    ...nextModules.map(mod => ({
      type: 'category' as const,
      label: mod.title,
      items: generateStudyIds('next-study', 'next', mod.start, mod.end),
    })),
  ],
};

export default sidebars;
